// SPDX-License-Identifier: GNU General Public License
pragma solidity 0.6.0;

import "@openzeppelin/contracts/access/Ownable.sol";

/// @title An implementation of an online marketplace using Ethereum
/// @author Rodrigo Ortega
/// @notice You can use this contract for actions related to the online marketplace (listing items, buying items, etc.)
contract OnlineMarketplace is Ownable {
    
    event StoreCreated(string newStoreName, address owner, uint storeID);
    event StoreUpdated(address indexed seller, uint _storeID, string _name, string _description, string _website, string _email);
    event ProductCreated(string newProductName, uint price, uint SKU, uint quantity, uint uniqueID, address seller, uint storeID);
    event ProductUpdated(string newProductName, uint price, uint SKU, uint quantity, uint uniqueID, address seller, uint storeID);
    event ProductSold(uint orderID, uint indexed productID, address indexed buyer, address indexed seller, uint price, string email);
    event ProductShipped(uint orderID, uint productID, uint trackingNumber, address indexed seller, address indexed buyer);
    event UserRegistered(address indexed user, string email);

/// @dev incremented by 1 to assign unique IDs to stores and products
    uint internal ID;

/// @dev holds contract balance
    uint public balance;

/// @notice bool for circuit breaker used in function modifier requireIsActive()
/// @dev value can be toggled using toggleCircuitBreaker() function by contract owner
    bool public isActive = true;

/// @dev struct for properties of a store object
    struct Stores {
        string name;
        address owner;
        uint storeID;
        string description;
        string website;
        string email;
    }
    
/// @dev struct for properties of a product object
    struct Products {
        string name; 
        string description;
        uint price;
        uint SKU;
        uint quantity;
        uint uniqueID;
        bool shipped;
        uint trackingNumber;
        address buyer;
        address payable seller;
        uint storeID;
        uint orderID;
    }
    
/// @dev array used for listing all stores on front page of user-interface (store directory)
    Stores[] public storesArray;

/// @dev mapping of unique ID to Products
    mapping (uint => Products) public productsMapping;

/// @dev mapping of unique ID to Stores
    mapping (uint => Stores) public storesMapping;

/// @dev mapping of address to array of Stores owned by address
    mapping (address => Stores[]) public stores;

/// @dev mapping of Store ID to array of Products available at that store
    mapping (uint => Products[]) public products;

/// @dev mapping of address to string for contact email
    mapping (address => string) public emails;

/// @dev mapping of order ID to product sold
    mapping (uint => mapping (uint => Products)) public orders;

/// @notice modifier placed in functions for circuit breaker
/// @dev isActive default value is true; toggle using toggleCircuitBreaker()
    modifier requireIsActive() {
        require(isActive == true);
        _;
    }
    
/// @notice function increments ID variable to generate unique IDs
/// @dev increments variable uint ID by 1 to generate unique IDs for products and stores
    function getID() public returns (uint) {
        return ++ID;
    }

/// @notice getter function for array length of Stores array
/// @dev called externally, used for displaying list of all stores in front-end
/// @return length of Stores array
    function getArrayLength() external view returns (uint length) {
        return storesArray.length;
    }

/// @notice getter function for array length of Stores array in mapping (address key)
/// @dev called externally, used for displaying list of stores owned by specific address in front-end
/// @return length of Stores array in mapping (address key)
    function getStoresMALength() external view returns (uint) {
        return stores[msg.sender].length;

    }

/// @notice getter function for array length of Products array in mapping (store ID key)
/// @dev called externally, used for displaying list of products owned by specific store ID in front-end
/// @param _storeID The unique store ID generated by getID() called during creation of newStore
/// @return length of Products array in mapping (store ID key)
    function getProductsMALength(uint _storeID) external view returns (uint) {
        return products[_storeID].length;
    }

/// @notice getter function for Products struct values in mapping (unique ID key) - split into A and B functions
/// @dev used in testing for retrieving values of Products struct by product ID
/// @param _uniqueID The unique product ID generated by getID() called during creation of newProduct
    function getProductA (uint _uniqueID) external view returns (string memory name, string memory description, uint price, uint SKU, uint quantity, uint uniqueID) {
        return (productsMapping[_uniqueID].name, productsMapping[_uniqueID].description, productsMapping[_uniqueID].price, productsMapping[_uniqueID].SKU, productsMapping[_uniqueID].quantity, productsMapping[_uniqueID].uniqueID);
    }

/// @notice getter function for Products struct values in mapping (unique ID key)- split into A and B functions
/// @dev used in testing for retrieving values of Products struct by product ID
/// @param _uniqueID The unique product ID generated by getID() called during creation of newProduct
    function getProductB (uint _uniqueID) external view returns (bool shipped, uint trackingNumber, address buyer, address seller, uint storeID, uint orderID) {
        return (productsMapping[_uniqueID].shipped, productsMapping[_uniqueID].trackingNumber, productsMapping[_uniqueID].buyer, productsMapping[_uniqueID].seller, productsMapping[_uniqueID].storeID, productsMapping[_uniqueID].orderID);
    }

/// @notice getter function for mapping of array of Product structs (store ID key)
/// @dev called externally, used for retrieving products by store ID in front-end
/// @param _storeID The unique store ID
/// @param _index The index value for the location of the Product struct in the array
/// @return name of the product
    function getProductsMA(uint _storeID, uint _index) external view returns (string memory) {
        return products[_storeID][_index].name;
    }

/// @notice getter function for Stores struct in mapping (store ID key)
/// @dev returns Stores struct values from mapping (store ID key) in front-end
/// @param _storeID The unique store ID
/// @return name of the store
    function getStore(uint _storeID) external view returns (string memory) {
        return storesMapping[_storeID].name;
    }

/// @notice getter function for mapping of email addresses (address key)
/// @dev called externally, used for retrieving a person's email address using thee associated Ethereum public address in front-end
/// @param _address The person's Ethereum public address
/// @return email address
    function getEmail(address _address) external view returns (string memory email, address buyer) {
        return (emails[_address], _address);
    }

/// @notice getter function for contract's current balance
/// @dev called externally, used for retrieving contract's current balance in front-end
/// @return current balance of this contract
    function getContractBalance() external view returns (uint) {
        return address(this).balance;
    }

/// @notice function for creating a new store
/// @dev built in circuit-breaker; called externally, used for creating a new Store object
/// @param _name The store's name
/// @param _description The store's description
/// @param _website The store's website
/// @param _email The store's contact email address
    function newStore(string calldata _name, string calldata _description, string calldata _website, string calldata _email) external payable requireIsActive {     
        require (msg.value == .005 ether);
        balance += msg.value;
        Stores memory a;
        a.name = _name;
        a.owner = msg.sender;
        a.storeID = getID();
        a.description = _description;
        a.website = _website;
        a.email = _email;
        insertStore(a, a.storeID);
        emit StoreCreated(_name, msg.sender, a.storeID);
    }

/// @dev private function, called during previous function to add new Store object to storage variables
    function insertStore(Stores memory a, uint _storeID) private {
        stores[msg.sender].push(a);
        storesMapping[_storeID] = a;
        storesArray.push(a);
    }

/// @notice function for creating a new product
/// @dev built-in circuit breaker; called externally, used for creating a new Product object
/// @param _name The product's name
/// @param _description The product's description
/// @param _price The product's price
/// @param _SKU The product's SKU
/// @param _quantity The product's quantity
/// @param _storeID The unique ID of the product's associated store
    function newProduct(string calldata _name, string calldata _description, uint _price, uint _SKU, uint _quantity, uint _storeID) external payable requireIsActive {
        require (msg.value == .001 ether);
        balance += msg.value;
        Products memory c;
        c.name = _name;
        c.description = _description;
        c.price = _price;
        c.SKU = _SKU;
        c.quantity = _quantity;
        uint abc = getID();
        c.uniqueID = abc;
        c.seller = msg.sender;
        c.storeID = _storeID;
        insertProduct(c, _storeID, abc);
        emit ProductCreated(_name, _price, _SKU, _quantity, abc, msg.sender, c.storeID);
    }

/// @dev private function, called during previous function to add new Product object to storage variables
    function insertProduct(Products memory c, uint storeID, uint _uniqueID) private {
        products[storeID].push(c);
        productsMapping[_uniqueID] = c;
    }

/// @notice function for editing an existing product
/// @dev built-in circuit breaker; called externally, used for editing an existing, listed Product
/// @param _index The product's index # in the products array
/// @param _name The product's name
/// @param _description The product's description
/// @param _price The product's price
/// @param _SKU The product's SKU
/// @param _quantity The product's quantity
/// @param _storeID The unique ID of the product's associated store
/// @param _uniqueID The product's unique ID
    function editProduct(uint _index, string calldata _name, string calldata _description, uint _price, uint _SKU, uint _quantity, uint _storeID, uint _uniqueID) external requireIsActive {

        products[_storeID][_index].name = _name;
        products[_storeID][_index].description = _description;
        products[_storeID][_index].price = _price;
        products[_storeID][_index].SKU = _SKU;
        products[_storeID][_index].quantity = _quantity;

        productsMapping[_uniqueID].name = _name;
        productsMapping[_uniqueID].description = _description;
        productsMapping[_uniqueID].price = _price;
        productsMapping[_uniqueID].SKU = _SKU;
        productsMapping[_uniqueID].quantity = _quantity;

        emit ProductUpdated(_name, _price, _SKU, _quantity, _uniqueID, msg.sender, _storeID);
    }

/// @notice function for editing an existing store
/// @dev built-in circuit breaker; called externally, used for editing an existing, listed store
/// @param _index The store's index # in the stores array
/// @param _storeID The unique ID of the store
/// @param _name The store's name
/// @param _description The store's description
/// @param _website The store's website
/// @param _email The store's email
    function editStore(uint _index, uint _storeID, string calldata _name, string calldata _description, string calldata _website, string calldata _email) external requireIsActive {     
        require(storesMapping[_storeID].owner == msg.sender);
        stores[msg.sender][_index].name = _name;
        stores[msg.sender][_index].description = _description;
        stores[msg.sender][_index].website = _website;
        stores[msg.sender][_index].email = _email;

        storesMapping[_storeID].name = _name;
        storesMapping[_storeID].description = _description;
        storesMapping[_storeID].website = _website;
        storesMapping[_storeID].email = _email;

        emit StoreUpdated(msg.sender, _storeID, _name, _description, _website, _email);
    }
    
/// @notice function executed when purchasing a product 
/// @dev called externally, checks for the product price to be equal to tx value sent and that product is in stock, then sets "sold" property to true and sends value to seller
/// @param _productID The product's unique ID
    function buyItem(uint _productID) external payable requireIsActive {
        require (msg.value == productsMapping[_productID].price);
        require (productsMapping[_productID].quantity > 0);
        require (bytes(emails[msg.sender]).length > 0, "You need to register an email address before purchasing an item.");
        productsMapping[_productID].seller.transfer(msg.value);
        productsMapping[_productID].quantity -= 1;
        uint orderID = getID();
        orders[orderID][_productID] = productsMapping[_productID];
        orders[orderID][_productID].buyer = msg.sender;
        orders[orderID][_productID].orderID = orderID;

        emit ProductSold(orderID,_productID, msg.sender, productsMapping[_productID].seller, productsMapping[_productID].price, emails[msg.sender]);
    }

/// @notice setter function for updating trackingNumber once product is shipped
/// @dev called externally by seller, used for updating trackingNumber and shipped values in mapping of Products (_uniqueID key)
/// @param _orderID The order ID associated with the product being shipped
/// @param _productID The product's unique ID
/// @param _trackingNumber The product's tracking number when shipped
    function itemShipped(uint _orderID, uint _productID, uint _trackingNumber) external {
        require(orders[_orderID][_productID].seller == msg.sender);
        orders[_orderID][_productID].trackingNumber = _trackingNumber;
        orders[_orderID][_productID].shipped = true;
        emit ProductShipped(_orderID, _productID, _trackingNumber, productsMapping[_productID].seller, orders[_orderID][_productID].buyer);
    }

/// @notice function to register an email address
/// @dev updates mapping of email addresses using msg.sender as key (address key)
/// @param _email email address of the person calling the function
    function register(string calldata _email) external requireIsActive {
        emails[msg.sender] = _email;
        emit UserRegistered(msg.sender, _email);
    }

/// @notice getter function for retrieving the contract's current balance
/// @dev called externally, used for updating the contract's current balance in the front-end
/// @return balance, The contract's current balance
    function getBalance() external view returns (uint) {
        return address(this).balance;       
    }

/// @notice function to withdraw all funds from the contract
/// @dev built-in circuit breaker; called externally by contract owner, used for withdrawing all available funds in the contract
    function withdrawAll() external onlyOwner requireIsActive {
        uint toTransfer = balance;
        balance = 0;
        msg.sender.transfer(toTransfer);    
    }

/// @notice function to initiate the contract's circuit breaker (freeze certain contract functions)
/// @dev called externally by contract's owner, toggles isActive bool variable to enable or disable circuit breaker
    function toggleCircuitBreaker() external onlyOwner {
        isActive = !isActive;
    }
}
